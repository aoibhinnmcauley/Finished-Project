/*
-----------------------------------------------------------------------------
Filename:    BaseApplication.h
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
#ifndef __BaseApplication_h_
#define __BaseApplication_h_

#include <OgreCamera.h>
#include <OgreEntity.h>
#include <OgreLogManager.h>
#include <OgreRoot.h>
#include <OgreViewport.h>
#include <OgreSceneManager.h>
#include <OgreRenderWindow.h>
#include <OgreConfigFile.h>
#include <OgreLogManager.h>

#include <OISEvents.h>
#include <OISInputManager.h>
#include <OISKeyboard.h>
#include <OISMouse.h>

#include <SdkTrays.h>
#include <SdkCameraMan.h>
using namespace std;
#include <sstream>
#include <vector>
#include <list>
class Cube; 
class zShape;
class box;
class tShape;
class tShapeOpp;
class lShape;
class lShapeOpp;

//FMOD includes
#pragma comment(lib,"fmodex_vc.lib")
#include "fmod.hpp"
#include "Gui3D.h" 
#include "Gui3DPanel.h"
#include "MySimpleDemoPanelColors.h"

class BaseApplication : public Ogre::FrameListener, public Ogre::WindowEventListener, public OIS::KeyListener, public OIS::MouseListener, OgreBites::SdkTrayListener
{
public:
    BaseApplication(void);
    virtual ~BaseApplication(void);

    virtual void go(void);

	/*! the main tick value for dropping shapes in milliseconds
	(changes the speed in which the shapes dropp) */
	int mainTickValue;

	

protected:
    virtual bool setup();
    virtual bool configure(void);
    virtual void chooseSceneManager(void);
    virtual void createCamera(void);
    virtual void createFrameListener(void);
    virtual void createScene(void) = 0; // Override me!
    virtual void destroyScene(void);
    virtual void createViewports(void);
    virtual void setupResources(void);
    virtual void createResourceListener(void);
    virtual void loadResources(void);

    /*! Ogre::FrameListener */
    virtual bool frameRenderingQueued(const Ogre::FrameEvent& evt);

     /*! OIS::KeyListener*/
    virtual bool keyPressed( const OIS::KeyEvent &arg );
    virtual bool keyReleased( const OIS::KeyEvent &arg );
    /*!OIS::MouseListener*/
    virtual bool mouseMoved( const OIS::MouseEvent &arg );
    virtual bool mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id );
    virtual bool mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id );

    /*!Ogre::WindowEventListener*/
    //Adjust mouse clipping area
    virtual void windowResized(Ogre::RenderWindow* rw);
    //Unattach OIS before window shutdown (very important under Linux)
    virtual void windowClosed(Ogre::RenderWindow* rw);

	
	/*!This method gets a random shape from an option of 6 and then sets a bool to true to say that shape has been used,
	This is an adaptation of the 7 bag algorithm used in tetris the shape cannot be used again until all shapes bools have been set to true
	(This creates semi-randomly generated shapes as completely random would make the game unplayable)*/
	virtual void randomShape();
	
	/*!creates the GUI interface*/
	void createGUI();
	/*! integer used to indicate what height a layer has been cleared from the 3D Array */
	int arrayClearHeight;
	/*! integer used to store the array height */
	int arrayHeight;
	/*! integer used to store the array width */
	int arrayWidth;
	/*! integer used to store the array depth */
	int arrayDepth;
	
	/*!This method goes through the 3D array starting from the clearHeight and moves each cell above the height down one in the y-direction (if the cell is not null) */
	virtual void dropLevelIn3DArray(int arrayClearHeightNew);
	/*!This method iterates up a level to the next level */
	virtual void nextLevel();
	/*!This method checks if the cells above the array are empty and if not it ends the game */
	virtual void checkForEndGame();
	
	/*!logger used for error checking*/
	Ogre::Log*	m_pLog;
    Ogre::Root *mRoot;
	/*! camera  */
    Ogre::Camera* mCamera;
	/*! sceneManager */
    Ogre::SceneManager* mSceneMgr;
	/*! renderWindow  */
    Ogre::RenderWindow* mWindow;
    Ogre::String mResourcesCfg;
    Ogre::String mPluginsCfg;

    /*! Ogre bites */
    OgreBites::SdkTrayManager* mTrayMgr;
    OgreBites::SdkCameraMan* mCameraMan;     // basic camera controller
    OgreBites::ParamsPanel* mDetailsPanel;   // sample details panel
    bool mCursorWasVisible;      			// was cursor visible before dialog appeared
	/*! bool used to end the game */
    bool mShutDown;

	/*! (the grid) an empty 3D array of cubes used to store pointers to cubes as shapes drop into place into the grid constantly changed and updated with new positions */
	vector<vector<vector<Cube*>>> array3D;


	/*! GUID main object  */ 
	Gui3D::Gui3D* mGui3D; 
	/*! The Main Panel  */ 
	Gui3D::Panel* mPanel; 
	MySimpleDemoPanelColors mMySimpleDemoPanelColors;

	/*! an enumeration used to indicate what the current shape type being used by the player is  */
	enum CurrentShapeType {zShapeType, boxType,tShapeType, tShapeOppType,lShapeType,lShapeOppType} currentShapeType;
	
	/*! a bool for each shape used to indicate if the shape has been used in one iteration of the 7 bag algorithm (will reset to false when every shape has been used once allowing the shapes to be used again)  */
	bool usedZShape, usedBoxShape,usedTShape, usedTShapeOpp,usedlShape,usedlShapeOpp;
	
	/*! an integer value for each shape used to iterate through the vector for every type of shape and to keep track of the current position in the vectors */
	int currentZShapeCell, currentBoxShapeCell, currentTShapeCell,currentTShapeOppCell,currentlShapeCell,currentlShapeOppCell;
	
	/*! vector containers used to store each type of shape and to allow for many instances of each shape
	( I considered using a heterogenous container but decided not to) 
	(also I know that there is a memory leak as I do not currently delete shapes in the cells that are not shown during gameplay */
	vector<box*> boxes;
	vector<zShape*> zShapes;
	vector<tShape*> tShapes;
	vector<tShapeOpp*> tOppShapes;
	vector<lShape*> lShapes;
	vector<lShapeOpp*> lOppShapes;
	
	
    /*! Input devices */
    OIS::InputManager* mInputManager;
    OIS::Mouse*    mMouse;
    OIS::Keyboard* mKeyboard;
	
	
	
	
	
	/*! amount of full layers cleared */
	int layersCleared;
	/*! variable used to store an integer to progressing to the next level */
	int nextLevelInt;
	/*! the amount of layers that need to be cleared before progressing to the next level  */
	int nextLevelAmount;
	/*! The current level */
	int currentLevel;
	/*! score */
	int score;
	/*! score multiplier */
	int scoreMultiplier;
	
	/*! timer */
	Ogre::Timer _timer;

	/*! music and effects for FMOD */
	bool music;
	bool effects;
	
	/*! initialisation bool for when game starts to show GUI and to call the first random shape */
	bool init;

	int timerCHECK;
	
	/*! all FMOD obejects needed for sound */
	FMOD::System *FMODsys; //the FMOD sytem
	FMOD_RESULT result;
	FMOD::Sound *sound;
	FMOD::Sound *soundStart;
	FMOD::Sound *soundDrop;
	FMOD::Channel *channel;
	FMOD::Channel *channel2;
	FMOD::Channel *channel3;
	FMOD::Reverb *reverb;
	FMOD::Reverb *reverb2;

};

#endif // #ifndef __BaseApplication_h_
#include "Cube.h"
#include "zShape.h"
#include "box.h"
#include "tShape.h"
#include "tShapeOpp.h"
#include "lShape.h"
#include "lShapeOpp.h"